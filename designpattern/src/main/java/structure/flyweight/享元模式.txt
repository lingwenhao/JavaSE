享元模式(Flyweight):
    描述:
        -主要用于减少创建的对象数量，可以减少内存占用和减少GC次数从而提高性能。这种类型的设计模式属于结构模
         式，因为该模式提供了减少对象数量的方法，从而改善了应用程序的对象结构。
        -细粒度的对象就是被共享的元数据
    角色分析:
        -Flyweight (享元抽象类)：一般是接口或者抽象类，定义了享元类的公共方法。这些方法可以分享内部状态的数据，也可以调用这些方法修改外部状态。
        -ConcreteFlyweight(具体享元类)：具体享元类实现了抽象享元类的方法，为享元对象开辟了内存空间来保存享元对象的内部数据，同时可以通过和单例模式结合只创建一个享元对象。
        -UnshareConcreteFlyweight(非共具体享元类):并不是所有的享元类都需要被共享的有的享元类就不要被共享，可以通过享元类来实例一个非共享享元对象。
        -Flyweight(享元工厂类)：享元工厂类创建并且管理享元类，享元工厂类针对享元类来进行编程，通过提供一个享元池来进行享元对象的管理。一般享元池设计成键值对，或者其他的
                存储结构来存储。当客户端进行享元对象的请求时，如果享元池中有对应的享元对象则直接返回对应的对象，否则工厂类创建对应的享元对象并保存到享元池。
    优点:
		-减少创建的对象数量
	缺点:
	    -提高了系统的复杂度。需要分离出内部状态和外部状态，而外部状态具有固化特性，不应该随着内部状态的改变而改变
	示例/场景:
		-池技术:String常量池、数据库连接池
	注意事项:
	    -享元工厂一般设置成单例的
	    -重点在于区分变化和不变化的对象
	深入分析:
	    -细粒度和共享对象
	        分配太多的对象到应用程序中将有损程序的性能，同时还容易造成内存溢出，要避免这种情况，用到的就是共享技术，这里就需要提到内部状态和外部状态了。
	    -内部状态和外部状态
	        指对象共享出来的信息，存储在享元对象内部并且不会随环境的改变而改变；外部状态指对象得以依赖的一个标记，是随环境改变而改变的、不可共享的状态。
	        如:棋子颜色就是棋子的内部状态,方位坐标就是棋子的外部状态。


