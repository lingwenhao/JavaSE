观察者模式:(Observer)
    描述:
        定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态发生变化时，会通知所有观察者对象，使它们能够自动更新自己
    好处:

    示例:

    角色分析:
        Subject(目标对象接口):
            一个目标可以被多个观察者观察
            目标提供注册观察者和移除观察者的方法
            当目标状态发生变化时,目标负责通知所有注册的、有效的观察者
        Observer(观察者的接口):
            定义观察者的接口,提供目标通知时对应的更新方法,这个更新方法进行相应
            的业务处理,可以在这个方法里面回调目标对象,以获取目标对象的数据
        ConcreteSubject(目标对象的实现对象):
            用来维护目标状态,当目标对象的状态发生改变时,通知所有注册有效的观察者,让观察者
            执行相应的处理
        ConcreteObserver(具体的观察者):
            观察者的具体实现对象,用来接收目标的通知,并进行相应的后续处理,比如更新自身的状态
            以保持和目标的相应状态一致
    深入分析:观察者模式分为推拉模型
    推模型
        1.目标对象主动向观察者推送目标的详细信息，不管观察者是否需要，推送的信息通常是目标对象的全部或部分数据，相当
          于是在广播通信
        2.推模型是假定目标对象知道观察者需要的数据
    拉模型
        1.目标对象在通知观察者的时候，只传递少量信息，如果观察者需要更具体的信息，由观察者主动到目标对象中获取，相当
          于是观察者从目标对象中拉数据。
        2.拉模型是目标对象不知道观察者具体需要什么数据，没有办法的情况下，干脆把自身传给观察者，让观察者自己去按需取值。

    推模型可能会使得观察者对象难以复用，因为观察者定义的update方法是按需而定义的，可能无法兼顾没有考虑到的使用情况。
    这就意味着出现新情况的时候，就可能需要提供新的update方法，或者是干脆重新实现观察者。 而拉模型就不会造成这样的
    情况，因为拉模型下，update方法的参数是目标对象本身，这基本上是目标对象能传递的最大数据集合了，基本上可以适应各
    种情况的需要。

    注意事项:不要把被观察者管理和通知和方法和触发通知的方法定义在一个类里面，而是要把这些方法抽象出来，“和触发通知的发放分离